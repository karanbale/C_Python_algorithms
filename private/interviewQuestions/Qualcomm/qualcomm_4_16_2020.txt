Question 1:
What is going on in following program and what is wrong with it?
Assume that mem 0xa5a5a5a5 gets updated whenever you press a button and gets 
a value of 0xb3.
If you release the button, it gets a value of 0xb1.
Now, what is output of this program, what is wrong with it?
How can you fix it?

int *ptr;
ptr = (int *)0xa5a5a5a5; // has value 0xb1
while(1){
    printf("%X",*ptr);
    delayMS(1);
}

output observed:
0xb1
0xb1
0xb1
0xb1
....
0xb1

Answer:
We have a pointer pointing to mem address 0xa5a5a5a5.
Now this pointer's being dereferenced and its value is being printed every 1 millisecond.
This value is always going to be same, because, compiler does optimization.
Compiler will see, same mem address is being referenced again and again, and then it will 
fetch this value locally, and keep updating it.
So if you keep updating same value, it will never fetch new value.
To work around this compiler optimization, we declare pointer as volatile.
Thus, for a volatile pointer, compile will cause CPU instructions to fetch from address rather
than locally store the value.

Question 2:
char *ptr;
void func(){
    ptr = (char *)malloc(100*sizeof(char));
    ....
    ....
    ....
}

What is wrong with above program ? elaborate:

Answer:
    In above program we are allocating memory on the heap, however we are never freeing it.
    So it will lead to memory leak. 

Question 3:
char *ptr;
void func(){
    ptr = (char *)malloc(100*sizeof(char));
    ....
    ....
    ....
    free(ptr);
}
printf("%x %x",*ptr,*(ptr+1));

Now that we have fixed the memory leak, do you think this program will work?
If you think there is still issues, how would you fix those?

Answer:
    This program still will not work, because now we have undefined behavior.
    We assigned some data to pointer, then freed it, so that pointer is now a dangling pointer.
    Operating on a dangling pointer leads to undefined behavior.
    It may print garbage value or may crash the program.
    To fix this, we need to make the pointer NULL.

    char *ptr;
    void func(){
        ptr = (char *)malloc(100*sizeof(char));
        ....
        ....
        ....
        free(ptr);
    }
    ptr = NULL;
    printf("%x %x",*ptr,*(ptr+1));

Question 4:
    What is interrupt latency?
Answer:
    interrupt latency is the time taken from firing of an interrupt to the invocation of ISR.

Question 5:
    How would you measure exact interrupt latency?
Answer:
    You can set a GPIO high whenever interrupt is fired, and when you enter ISR, the first thing 
    you do is set same GPIO low and measure these rising and falling edges on an oscilloscope,
    and take differencce of the two along X-axis to get exact interrupt latency in terms of time.

Question 6:
    What is ISR? What is IVT? Can you pass any argument to ISR or return any argument from ISR?
Answer:
    ISR stands for interrupt service routine.
        ISR gets invoked every time an interrupt is fired.
        ISR has predefined time limit for its execution.
        ISR must be executed in as small time frame as possible.
        ISR cannot return any argument or process any input arguments, because,
        ISR may enter deadlock, if argument being processed is held by any othe process.
    IVT stands for interrupt vector table.
        IVT holds function pointer address of functions which we should execute, whenever an interrupt
        is fired. 

