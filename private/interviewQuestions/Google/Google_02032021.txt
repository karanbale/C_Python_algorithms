Round 1:
- Given an input N, write a function that will return all valid fractions under N satisfying following conditions:
1. Fraction must be between 0 and 1
2. Fractions must be unique i.e. no duplicates.
	e.g. 2/4 is nothing but 1/2, so only have 1/2 in the output
3. Fractions must be sorted

#define SIZE 100

typedef struct fractions{
	int numerator;
	int denominator;
}fractions_t;

// euclidean method
int getGCD(int numerator, int denominator){

	int remainder = 0;
	while(denominator){
		remainder = numerator % denominator;
		numerator = denominator;
		denominator = remainder;
	}
	return numerator;
}

int getLCM(int numerator, int denominator){
	int max;
	// start with the biggest numerator 
    max = (numerator > denominator) ? numerator : denominator;
    while (1) {
		// find the first biggest number that is divisible by both
		// numerator and denominator
        if (max % numerator == 0 && max % denominator == 0)
            break;
        ++max;
    }
    return max;
}

int compare(const void *a, const void *b){
    const fractions_t *f1 = *(fractions_t **)a;
    const fractions_t *f2 = *(fractions_t **)b;\
    double xx = ((double)f1->numerator/f1->denominator);
    double yy = ((double)f2->numerator/f2->denominator);\
    if(xx > yy){
        return 1;
    }
    if(xx < yy){
        return -1;
    }
    return 0;
}

fractions_t *createFractions(int numerator, int denominator){
	fractions_t *node = malloc(sizeof(fractions_t));
	assert(node != NULL);
	node->numerator = numerator;
	node->denominator = denominator;
	return node;
}

int main()
{
    printf("Hello World\n");
    fractions_t **fractionsArr = (fractions_t *)calloc(SIZE, sizeof(fractions_t *));
    assert(fractionsArr != NULL);
    int N = 5;
	int idx = 0;
	for(int i = 0; i<=N; i++){
		for(int j = 1; j<=N; j++){
			// fractional division of  j > i will not satisfy condition 1
			if((getGCD(i,j) <= 1) && (j >= i))
			{
			    fractionsArr[idx++] = createFractions(i, j);
			    if(idx >= SIZE){
				    printf("size limit reached\n");
			    }
			}
		}
	}

	qsort(fractionsArr, idx, sizeof(fractionsArr[0]), compare);

	for(int i=0; i<SIZE; i++){
		if(fractionsArr[i]){
			fractions_t *node = fractionsArr[i];
			printf("%d/%d\n",node->numerator, node->denominator);
			free(node);
		}
	}
	free(fractionsArr);
    return 0;
}

Round 2:

Implement a message passing queue between two processors.
Communication needs to be asynchronous 
Used a circular queue to write to and read off the data.


Round 3:

You have an embedded system with a Linux-llke operating system (flat memory model, no userspace), and a touchscreen. 
It is multicore, has multiple tasks (or threads), and has whatever timers, locking, and
signals and threading/scheduling utilities you need.

Your goal is to draw a dot under the finger wherever someone is touching the screen. The finger can be moving.

-----

About the display: Your drawing utility was written by a “Friend”, prototype void draw(int x, int y);. 
draw() will erase the framebuffer, then draw a dot where you specify, and block until the framebuffer with the dot is given to the display controller. 
The display panel is video mode, 60 Hz constant vsync (vsync interrupt is from the panel, back to the CPU).

Your touch controller is on an 400 KHz I2C bus, and has one interrupt pin coming back to the CPU. 
When the interrupt fires, you have an X and Y position locked into two 16-bit registers at address 0 and 2 in the controller,
and they won’t change until you read them. You have a “touch_i2c_read(UINT16 reg, UINT16* val); ” utility. 
The touch interrupt will fire as fast as 120-150 Hz range, the sampling rate of the touch controller is not fixed, 
and it will only clear the interrupts (and give new data) after you’ve read the previous x/y coordinates out.

Part 1) Implement the touch interrupt service routine, and the main task that will draw the dot.

Utilities provided to you:
void draw(int x, int y); /* blocking until subsequent vsync */
void touch_i2c_read(UINT16 *x, UINT16 *y);
(plus any timers, task creation, locking and signals you need.)
(plus, any initialization you need will happen in a separate thread.
Lock initialization, data structures created ahead of time, task creation, etc,
don't implement that and just assume it's done.)

Your functions to implement (minimally):
void touch_isr(void); /* (edge triggerred interrupt service routine */
void draw_task(void); /* infinite loop, main task, if you need it */

// vsync => 60 hz
// touch intr => 120-150 hz

Bool isTouchIntrRegSet(INTR_T *touchIntr);
Bool clearTouchIntrReg(INTR_T *touchIntr);
Bool touch_isr_received = false;
INTR_T *touchIntr;
Void touch_isr(void){
	if(isTouchIntrRegSet(touchIntr) == 1){
Touch_isr_received = true;
clearTouchIntrReg(touchIntr);
}
}

Bool mutexLock = false;
Bool TestAndSet(bool *mutexLock){
	Bool *oldValue = mutexLock;
	mutexLock != mutexLock;
	Return oldValue;
}

bool aquireLock(void){
	while(!TestAndSet(mutexLock));
	Return true;
}

Void releaseLock(void){
	mutexLock = false;
}

void draw_task(void){
	Int x = -1;
	Int y = -1;
	if(Touch_isr_received){
	touch_i2c_read(&x, &y);
	Touch_isr_received = false;
	acquireLock();
	draw(x,y);
	delay(10);
}
}

Pthread_t *threads[10];
// setup threads => initialized with draw task, 
// acquire ids
// assign x and y values to threads to do the work when they are about to be executed

Void createAndQueueThread(void){
	for(int i=0; i<10; i++){
		Threads[i] = threads.create(i);
}
for(int i=0; i<10; i++){
	threads.join(*draw_task);
}
}


Round 4:


Round 5:

We'd like to analyze performance for response to an event or an operation
in a multithreaded system.
 - We're interested in wallclock time of the operation, not CPU time
 - We're OK with instrumenting the code to help define modules or sub-operations
 - We have spare RAM to store the instrumentation
 - We want to analyze performance w/ minimal impacting the performance itself

// we dont want to focus on CPU time
// no spare cores, use existing cores 
// impact of my operation is not noticable / not harmful
// explore options to send the data out => 

size_t dataLoggerTracker = 0;

typedef struct dataLogger{
	int logCount;
	char *moduleName;
	bool running;
	void *funcName;
}dataLogger_t;

dataLogger_t *createNode(char *name, void *funcName){
dataLogger_t *node = (dataLogger_t *) malloc(sizeof(dataLogger_t));
if(!node) return NULL;
node->logCount = dataLoggerTracker++;
node->moduleName = name;
node->funcName = funcName;
node->running = false;
return node;
}
void loggerWrapper(char *name, void *func){
//	create logger module
dataLogger_t *node = createNode(name, func);
	// log wall clock start time
	_LOGGER();
// instantiate thread
// wait for thread to finish
// log wall clock exit time
	
}
