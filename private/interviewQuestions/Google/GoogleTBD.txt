1. Design a DMA controller and then API for it. 
2. Find algorithm to plan a route of a spaceship on 2D grid to visit places while avoiding obstacles (Dijkstra). 
3. Write code to process a log file with timing marks from functions. 
4. Design a system to reduce/measure power consumption on a tiny embedded battery powered device
5. If you didn't have access to the functions malloc() and free(), describe how you would implement them.

https://igotanoffer.com/blogs/tech/google-software-engineer-interview

https://resources.workable.com/embedded-software-engineer-interview-questions

Write a driver wrapper API on top of an existing driver API.
Driver API
        size_t read(size_t* buf)   // this driver API reads 512 bytes from a pheripheral 
         
         // Write wrapper as below 
        size_t read_bytes(struct *rs, size_t* buf, size_t count) // You need to return count bytes in the buffer. 

https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/


You are given an infinite number of dice and you want to represent numbers with them.
A represented number is lining up dice faces to make up the number, so 11 is 2 dies of faces 1 and 1,
15 is one '1' facing die and one '5' facing die .
A number can only be represented fully or be a sum of fully represented numbers.for example:
* 66 can be represented fully
* 82 cannot as we don't have a die face for '8' so we have to find a number that sums to 82,
and is made up of representable number, so 82 can be 66 + 16 and that would be the correct representation

Given any number, you need to find the optimal way to represent it with the smalles number of representable numbers


System design interview questions:

1. How would you design a task scheduling system
2. How would you design a function that schedules jobs on a rack of machines,
knowing that each job requires a certain amount of CPU & RAM, and each machine has different amounts of CPU & RAM?
Multiple jobs can be scheduled on the same machine as long as it can support it.
3. We have a system designed to handle one hardware interrupt at a time.
Hardware interrupts are added to the system by a call (set_hw_interrupt), but when added, if another interrupt already exists,
(as in, has been added but hasn't been executed), it is overridden.
Design this system (basically code new member functions in a boilerplate class provided to me by the interviewer),
so that when a new interrupt is added, the system remembers all previous interrupts and executes them in the proper order.

    A few questions I would ask the interviewer are,

    Can there be multiple hardware interrupts at the same time?
    Can the number of interrupts be high?
    It’s already mentioned that hardware interrupt is handled by the system one at a time, so that’s clear.
    There can be other questions as well. However, let’s say the answers to both questions 1 and 2 are ‘yes’, then I would consider the following,

    Create a queue data structure, as it follows FIFO and guarantees the order if used properly.
    Since the number of interrupts can be high, hence, queue made of singly Linked List should suffice the two actions, 
    a) insert new interrupt at the head (time: O(1)) and 
    b) remove from the tail (time: O(1)). 

    Array won’t suffice constant time pop operation from the start of the array, hence a singly linked list looks like a good candidate here.
    To make sure multiple interrupts are captured in order, the linked list has to be concurrent safe.
    Since hardware interrupts are localized and not distributed, hence, a ‘mutex’ or ‘lock’ should help,
    (but should clarify with the interviewer on the requirement).
    The system takes the interrupts from the tail of the linked list (unless the tail is Null/Nil) and executes in order.
    Also, think of cases where the system responding to the interrupts falls below the expected processing rate due to the high volume of interrupts.
    Hope this makes some sense.

    From some phrases you mentioned - like 
    "handle one hardware interrupt at a time" - thinking threading, queuing, 
    "when added, if another interrupt already exists (as in, has been added but hasn't been executed), it is overridden" - thinking queuing, stacking, 
    "the system remembers all previous interrupts and executes them in the proper order" - thinking priority - queue, stack etc 

    Karan's questions to the interviewer to clarify requirements and outline them:
    - What is the maximum number of programmable interrupts ?
        This is because, if maximum number of programmable interrupts are relatively low, we can probably use a stack / queue as an array.
        If maximum number of programmable interrupts are super high, we can use stack / queue made out of linked-lists instead of an array.
    - What is the priority of the interrupts ? Is priority equal to the order in which interrupts are programmed / user can manually update the priority after
      programming the interrupts?
        If priority is equal to the order in which interrupts were programmed then maybe we can use priority queues.
        If priority can be changed later on, still use priority queues, but we will need another function to change priorities in run time.
    - Can we have any interrupts whose priority can never be changed once programmed ? e.g. reset / core-fault / system-exception / NMI (non-maskable interrupts)
        This is because, if we have such interrupts, we need to keep 2 things in mind:
        1) Prevent user from modifying interrupt priority of these interrupts in run time.
        2) These interrupts will have highest priority than any other interrupts.
    - Upon execution of the interrupt, we wish to preserve the interrupt for the life of the programm/ application? i.e. don't discard interrupt after it's serviced?
    - Can I expect an interrupt to occur while we're programming another interrupt / while it's not programmed ? How do you wish it to be handled?
    - Can I expect multiple interrupts to occur at the same time? If so I presume we want to execute them based on the priority and not the order in which they arrived?
    - These interrupts can be pre-emptive ?
    - I can assume the context switching between interrupt and normal program execution is well handled by current code?
    - Is there any timing limitation about interrupt latency in case we have multiple interrupts pending ?
    - What registers can I expect to be associated with this interrupt ?
        E.g. Active interrupt register 
                => To be marked active during ISR execution as second step after clearing pending register bit.
        Pending interrupt register 
                => To be marked pending, before context switching, to be cleared as first step during ISR execution. interrupt must be active.
        Enable interrupt register 
                => Mark interrupt as enabled by user.
        Disable interrupt register 
                => Mark interrupt as disabled by user.
        Priority interrupt register
                => Mark interrupt priority as given by user
    - Need to consider handling a case where we have outstanding interrupts with same priorities.
        Maybe create a separate priority register, where upper 4 bits are for priority pre-emption and lower 4 bits are for handling sub-priority
        (i.e. handling the case where you have two or more interrupts of same priority outstanding)
    - What is expectation when there are too many outstanding interrupts? What is maximum number of permissible outstanding interrupts?
    - 